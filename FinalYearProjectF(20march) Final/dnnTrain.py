# -*- coding: utf-8 -*-
"""dnn21A.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M4kk2ynNBUafffttrMInqmN1_bd44wo4
"""

import pandas as pd
import numpy as np
import re
import tensorflow as tf
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Embedding, Dense, Dropout, GlobalAveragePooling1D, BatchNormalization
from tensorflow.keras.utils import to_categorical
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
import pickle

# Load dataset
df = pd.read_csv("movie_reviews_DLP.csv")

# Aspect keywords
aspect_keywords = {
    "acting": ["acting", "actor", "actors", "performance", "performances", "cast", "role", "roles",
               "portrayal", "expressions", "dialogue", "screen presence", "chemistry", "delivery",
               "facial expressions", "body language", "acting skills"],
    "plot": ["plot", "story", "storyline", "script", "twist", "twists", "narrative", "theme",
             "screenplay", "structure", "pace", "climax", "intro", "ending", "build-up", "backstory",
             "story arc", "writing", "subplots", "conflict", "chronology", "plotline"],
    "sound": ["sound", "music", "score", "audio", "background score", "background music",
              "track", "melody", "tune", "composition", "soundtrack", "beats", "rhythm", "bass",
              "volume", "sound effects", "sound quality", "mixing", "sfx"],
    "visuals": ["visuals", "cinematography", "cgi", "graphics", "animation", "camera", "effects",
                "focus", "lighting", "color", "color grading", "frame", "shot", "angles", "vfx",
                "aesthetics", "scenery", "set design", "visual appeal", "cinematic", "cinematic style"],
    "direction": ["direction", "director", "directing", "vision", "filmmaking", "execution", "style",
                  "tone", "narrative flow", "pacing", "creative choices", "scene setup", "visionary",
                  "command", "directorial style", "cohesion", "presentation", "scene composition"],
    "thriller": ["thriller", "thrilling", "thrills", "suspense", "tension", "mystery", "crime",
                 "investigation", "detective", "clues", "twists", "twist", "shock", "surprise",
                 "mind-bending", "edge of the seat", "on edge", "plot twist", "unexpected", "unexpected twists"],
    "overall": []  # All accepted
}

# Clean review by extracting aspect-related clauses
# def extract_aspect_text(review, aspect):
#     review = review.lower()
#     clauses = re.split(r'[.!?;]| but | and | although | though | however | while ', review)
#     keywords = aspect_keywords.get(aspect.lower(), [])
#     matched = [c.strip() for c in clauses if any(k in c for k in keywords)]
#     return " ".join(matched) if matched else review

def extract_aspect_text(review, aspect):
    review = review.lower()
    keywords = aspect_keywords.get(aspect.lower(), [])

    # Focus on contrast-aware split first (CNN-style)
    for sentence in re.split(r' but | although | however | though | while ', review):
        if any(k in sentence for k in keywords):
            return sentence.strip()

    # Fallback: broader clause matching
    splitters = r'[.!?;]| but | and | although | however | though | while '
    sentences = re.split(splitters, review)
    matched = [s.strip() for s in sentences if any(k in s for k in keywords)]

    return " ".join(matched) if matched else review


    # Prioritizes relevant clauses:
    for sentence in re.split(r' but | although | however | though | while ', review):
        if any(k in sentence for k in keywords):
            return sentence.strip()

# Apply cleaning
df["Cleaned_Review"] = df.apply(lambda row: extract_aspect_text(str(row["Review"]), str(row["Aspect"])), axis=1)

# Tokenization
MAX_WORDS = 20000
MAX_LEN = 100
tokenizer = Tokenizer(num_words=MAX_WORDS, oov_token="<OOV>")
tokenizer.fit_on_texts(df["Cleaned_Review"].values)
sequences = tokenizer.texts_to_sequences(df["Cleaned_Review"].values)
X = pad_sequences(sequences, maxlen=MAX_LEN, padding='post', truncating='post')

# Label encoding
aspect_encoder = LabelEncoder()
aspects = aspect_encoder.fit_transform(df["Aspect"].values)
label_encoder = LabelEncoder()
labels = label_encoder.fit_transform(df["Sentiment"].values)
y = to_categorical(labels, num_classes=3)

# Train/Test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, stratify=y, random_state=42)

# DNN model
model = Sequential([
    Embedding(input_dim=MAX_WORDS, output_dim=128, input_length=MAX_LEN),
    GlobalAveragePooling1D(),
    BatchNormalization(),
    Dropout(0.4),
    Dense(64, activation='relu'),
    Dropout(0.5),
    Dense(3, activation='softmax')
])

model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

# Train
early_stopping = tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=3, restore_best_weights=True)
model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=20, batch_size=32, callbacks=[early_stopping], verbose=1)

# Save model and encoders
model.save("Model/dnn_aspect_sentiment_model.h5")
with open("Model/dnn_tokenizer.pkl", "wb") as f:
    pickle.dump(tokenizer, f)
with open("Model/dnn_label_encoders.pkl", "wb") as f:
    pickle.dump((label_encoder, aspect_encoder), f)

print("✅ DNN model retrained and saved successfully!")

# Only load once
_loaded_dnn_model = None
_loaded_dnn_tokenizer = None
_loaded_dnn_label_encoder = None
_loaded_dnn_aspect_encoder = None

def predict_sentiment_dnn(review, aspect):
    import re
    import numpy as np
    import pickle
    from tensorflow.keras.models import load_model
    from tensorflow.keras.preprocessing.sequence import pad_sequences

    global _loaded_dnn_model, _loaded_dnn_tokenizer, _loaded_dnn_label_encoder, _loaded_dnn_aspect_encoder

    MAX_LEN = 100

    # Load once only
    if _loaded_dnn_model is None:
        with open("Model/dnn_tokenizer.pkl", "rb") as f:
            _loaded_dnn_tokenizer = pickle.load(f)
        with open("Model/dnn_label_encoders.pkl", "rb") as f:
            _loaded_dnn_label_encoder, _loaded_dnn_aspect_encoder = pickle.load(f)
        _loaded_dnn_model = load_model("Model/dnn_aspect_sentiment_model.h5")

    tokenizer = _loaded_dnn_tokenizer
    label_encoder = _loaded_dnn_label_encoder
    aspect_encoder = _loaded_dnn_aspect_encoder
    model = _loaded_dnn_model

    # Aspect keyword map
    aspect_keywords = {
        "acting": ["acting", "actor", "actors", "performance", "performances", "cast", "role", "roles",
                   "portrayal", "expressions", "dialogue", "screen presence", "chemistry", "delivery",
                   "facial expressions", "body language", "acting skills"],
        "plot": ["plot", "story", "storyline", "script", "twist", "twists", "narrative", "theme",
                 "screenplay", "structure", "pace", "climax", "intro", "ending", "build-up", "backstory",
                 "story arc", "writing", "subplots", "conflict", "chronology", "plotline"],
        "sound": ["sound", "music", "score", "audio", "background score", "background music",
                  "track", "melody", "tune", "composition", "soundtrack", "beats", "rhythm", "bass",
                  "volume", "sound effects", "sound quality", "mixing", "sfx"],
        "visuals": ["visuals", "cinematography", "cgi", "graphics", "animation", "camera", "effects",
                    "focus", "lighting", "color", "color grading", "frame", "shot", "angles", "vfx",
                    "aesthetics", "scenery", "set design", "visual appeal", "cinematic", "cinematic style"],
        "direction": ["direction", "director", "directing", "vision", "filmmaking", "execution", "style",
                      "tone", "narrative flow", "pacing", "creative choices", "scene setup", "visionary",
                      "command", "directorial style", "cohesion", "presentation", "scene composition"],
        "thriller": ["thriller", "thrilling", "thrills", "suspense", "tension", "mystery", "crime",
                     "investigation", "detective", "clues", "twists", "twist", "shock", "surprise",
                     "mind-bending", "edge of the seat", "on edge", "plot twist", "unexpected", "unexpected twists"],
        "overall": []
    }

    # Aspect check
    aspect_lower = aspect.lower()
    available_aspects = [a.lower() for a in aspect_encoder.classes_]
    if aspect_lower not in available_aspects:
        return f"❌ Error: The aspect '{aspect}' is unavailable. Available aspects: {aspect_encoder.classes_}"

    # Clause segmentation
    review = review.strip().lower()
    clauses = re.split(r'[.!?;]| but | and | although | though | however | while ', review)
    clauses = [clause.strip() for clause in clauses if clause.strip()]

    # Filter relevant clause(s)
    matched = []
    if aspect_lower != "overall":
        keywords = aspect_keywords.get(aspect_lower, [])
        for clause in clauses:
            if any(k in clause for k in keywords):
                matched.append(clause)
        if not matched:
            return f"❌ Error: The review is not discussing the aspect '{aspect}'."
        review_to_use = " ".join(matched)
    else:
        review_to_use = review

    # Predict
    sequence = tokenizer.texts_to_sequences([review_to_use])
    padded = pad_sequences(sequence, maxlen=MAX_LEN, padding='post', truncating='post')
    prediction = model.predict(padded, verbose=0)
    sentiment = label_encoder.inverse_transform([np.argmax(prediction)])
    return f"✅ Sentiment for '{aspect}': {sentiment[0]}"

print(predict_sentiment_dnn("The acting was brilliant and captivating.", "Acting"))
print(predict_sentiment_dnn("The visual effects were stunning and cinematic.", "Visuals"))
print(predict_sentiment_dnn("The music was dull and unmemorable.", "Sound"))
print(predict_sentiment_dnn("The story was confusing and lacked clarity.", "Plot"))
print(predict_sentiment_dnn("The music was amazing!", "Plot"))  # ❌ Should return error
print(predict_sentiment_dnn("Overall, it was an enjoyable experience.", "Overall"))

print(predict_sentiment_dnn("The acting was powerful and emotionally moving, but the visuals felt flat and uninspired. Meanwhile, the music score gave the film a haunting, unforgettable vibe that really stayed with me.", "Acting"))
print(predict_sentiment_dnn("The acting was powerful and emotionally moving, but the visuals felt flat and uninspired. Meanwhile, the music score gave the film a haunting, unforgettable vibe that really stayed with me.", "Visuals"))
print(predict_sentiment_dnn("The acting was powerful and emotionally moving, but the visuals felt flat and uninspired. Meanwhile, the music score gave the film a haunting, unforgettable vibe that really stayed with me.", "Sound"))

review = "The acting was powerful and emotionally moving, but the visuals felt flat and uninspired. Meanwhile, the music score gave the film a haunting, unforgettable vibe that really stayed with me."

print(predict_sentiment_dnn(review, "Acting"))
print(predict_sentiment_dnn(review, "Visuals"))
print(predict_sentiment_dnn(review, "Sound"))