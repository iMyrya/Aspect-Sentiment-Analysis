# -*- coding: utf-8 -*-
"""lstm20A.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JRBCx0gUxu1lJ6BufLIhSDyQwoxBzfEz
"""

# train_lstm.py

import pandas as pd
import numpy as np
import re
import pickle
import tensorflow as tf
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Embedding, Bidirectional, LSTM, Dense, Dropout, BatchNormalization
from tensorflow.keras.callbacks import EarlyStopping

# Load dataset
df = pd.read_csv("movie_reviews_DLP.csv")

aspect_keywords = {
    "acting": [
        "acting", "actor", "actors", "performance", "performances", "cast", "role", "roles",
        "portrayal", "expressions", "dialogue", "screen presence", "chemistry",
        "delivery", "facial expressions", "body language", "acting skills"
    ],
    "plot": [
        "plot", "story", "storyline", "script", "twist", "twists", "narrative", "theme",
        "screenplay", "structure", "pace", "climax", "intro", "ending", "build-up", "backstory",
        "story arc", "writing", "subplots", "conflict", "chronology", "plotline"
    ],
    "sound": [
        "sound", "music", "score", "audio", "background score", "background music",
        "track", "melody", "tune", "composition", "soundtrack", "beats", "rhythm", "bass",
        "volume", "sound effects", "sound quality", "mixing", "sfx"
    ],
    "visuals": [
        "visuals", "cinematography", "cgi", "graphics", "animation", "camera", "effects",
        "focus", "lighting", "color", "color grading", "frame", "shot", "angles", "vfx",
        "aesthetics", "scenery", "set design", "visual appeal", "cinematic", "cinematic style"
    ],
    "direction": [
        "direction", "director", "directing", "vision", "filmmaking", "execution", "style",
        "tone", "narrative flow", "pacing", "creative choices", "scene setup", "visionary",
        "command", "directorial style", "cohesion", "presentation", "scene composition"
    ],
    "thriller": [
        "thriller", "thrilling", "thrills", "suspense", "tension", "mystery", "crime",
        "investigation", "detective", "clues", "twists", "twist", "shock", "surprise",
        "mind-bending", "edge of the seat", "on edge", "plot twist", "unexpected", "unexpected twists"
    ],
    "overall": []  # Accepts all
}

# ---------------- CLAUSE EXTRACTION ---------------- #
def extract_aspect_text(text, aspect):
    text = text.lower()
    split_clauses = re.split(r'[.!?;]| but | and | although | however | though | while ', text)
    keywords = aspect_keywords.get(aspect.lower(), [])
    matched_clauses = [clause.strip() for clause in split_clauses if any(k in clause for k in keywords)]
    return " ".join(matched_clauses) if matched_clauses else text

# ---------------- DATA LOADING ---------------- #
df = pd.read_csv("movie_reviews_DLP.csv")
df["Cleaned_Review"] = df.apply(lambda row: extract_aspect_text(str(row["Review"]), str(row["Aspect"])), axis=1)

# ---------------- TOKENIZATION ---------------- #
MAX_WORDS = 20000
MAX_LEN = 100
tokenizer = Tokenizer(num_words=MAX_WORDS, oov_token="<OOV>")
tokenizer.fit_on_texts(df["Cleaned_Review"].values)
sequences = tokenizer.texts_to_sequences(df["Cleaned_Review"].values)
X = pad_sequences(sequences, maxlen=MAX_LEN, padding='post', truncating='post')

# ---------------- LABEL ENCODING ---------------- #
label_encoder = LabelEncoder()
aspect_encoder = LabelEncoder()
y = to_categorical(label_encoder.fit_transform(df["Sentiment"].values), num_classes=3)
aspects = aspect_encoder.fit_transform(df["Aspect"].values)

# ---------------- SPLIT ---------------- #
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, stratify=y, random_state=42
)

# ---------------- LSTM MODEL ---------------- #
model = Sequential([
    Embedding(input_dim=MAX_WORDS, output_dim=128, input_length=MAX_LEN),
    Bidirectional(LSTM(64, return_sequences=True)),
    BatchNormalization(),
    Dropout(0.4),
    Bidirectional(LSTM(32)),
    Dense(64, activation='relu'),
    Dropout(0.5),
    Dense(3, activation='softmax')
])

model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
early_stop = EarlyStopping(monitor='val_loss', patience=3, restore_best_weights=True)

# ---------------- TRAIN ---------------- #
model.fit(X_train, y_train, validation_data=(X_test, y_test),
          epochs=20, batch_size=32, callbacks=[early_stop], verbose=1)

# ---------------- SAVE ---------------- #
model.save("Model/lstm_aspect_sentiment_model.h5")
with open("Model/lstm_tokenizer.pkl", "wb") as f:
    pickle.dump(tokenizer, f)
with open("Model/lstm_label_encoders.pkl", "wb") as f:
    pickle.dump((label_encoder, aspect_encoder), f)

print("✅ LSTM model trained and saved successfully.")

def predict_sentiment_lstm(review, aspect):
    import pickle
    import numpy as np
    import re
    from tensorflow.keras.preprocessing.sequence import pad_sequences
    from tensorflow.keras.models import load_model

    MAX_LEN = 100

    # Load model and preprocessing tools
    with open("Model/lstm_tokenizer.pkl", "rb") as f:
        tokenizer = pickle.load(f)
    with open("Model/lstm_label_encoders.pkl", "rb") as f:
        label_encoder, aspect_encoder = pickle.load(f)
    model = load_model("Model/lstm_aspect_sentiment_model.h5", compile=False)

    aspect_keywords = {
    "acting": [
        "acting", "actor", "actors", "performance", "performances", "cast", "role", "roles",
        "portrayal", "expressions", "dialogue", "screen presence", "chemistry",
        "delivery", "facial expressions", "body language", "acting skills"
    ],
    "plot": [
        "plot", "story", "storyline", "script", "twist", "twists", "narrative", "theme",
        "screenplay", "structure", "pace", "climax", "intro", "ending", "build-up", "backstory",
        "story arc", "writing", "subplots", "conflict", "chronology", "plotline"
    ],
    "sound": [
        "sound", "music", "score", "audio", "background score", "background music",
        "track", "melody", "tune", "composition", "soundtrack", "beats", "rhythm", "bass",
        "volume", "sound effects", "sound quality", "mixing", "sfx"
    ],
    "visuals": [
        "visuals", "cinematography", "cgi", "graphics", "animation", "camera", "effects",
        "focus", "lighting", "color", "color grading", "frame", "shot", "angles", "vfx",
        "aesthetics", "scenery", "set design", "visual appeal", "cinematic", "cinematic style"
    ],
    "direction": [
        "direction", "director", "directing", "vision", "filmmaking", "execution", "style",
        "tone", "narrative flow", "pacing", "creative choices", "scene setup", "visionary",
        "command", "directorial style", "cohesion", "presentation", "scene composition"
    ],
    "thriller": [
        "thriller", "thrilling", "thrills", "suspense", "tension", "mystery", "crime",
        "investigation", "detective", "clues", "twists", "twist", "shock", "surprise",
        "mind-bending", "edge of the seat", "on edge", "plot twist", "unexpected", "unexpected twists"
    ],
    "overall": []  # Accepts all
}



    aspect_lower = aspect.lower()
    available_aspects = [a.lower() for a in aspect_encoder.classes_]

    if aspect_lower not in available_aspects:
        return f"❌ Error: The aspect '{aspect}' is unavailable. Available aspects: {aspect_encoder.classes_}"

    # Segment clauses
    review_lower = review.lower()
    clauses = re.split(r'[.!?;]| but | and | although | though | however | while ', review_lower)
    clauses = [c.strip() for c in clauses if c.strip()]
    keywords = aspect_keywords.get(aspect_lower, [])

    # Match clauses
    matched = [clause for clause in clauses if any(k in clause for k in keywords)]

    # If clause is very short or ambiguous, use full review as fallback
    if not matched and aspect_lower != "overall":
        return f"❌ Error: The review is not discussing the aspect '{aspect}'."
    elif matched and len(" ".join(matched).split()) < 4:
        review_to_use = review
    elif matched:
        review_to_use = " ".join(matched)
    else:
        review_to_use = review  # for overall or fallback

    # Predict
    seq = tokenizer.texts_to_sequences([review_to_use])
    padded = pad_sequences(seq, maxlen=MAX_LEN, padding='post', truncating='post')
    pred = model.predict(padded, verbose=0)
    sentiment = label_encoder.inverse_transform([np.argmax(pred)])
    return f"✅ Sentiment for '{aspect}': {sentiment[0]}"

print(predict_sentiment_lstm("The acting was amazing but the music was dull.", "Acting"))  # ✅ Positive
print(predict_sentiment_lstm("The acting was amazing but the music was dull.", "Sound"))   # ✅ Negative
print(predict_sentiment_lstm("The visuals were cinematic, though the story dragged.", "Visuals"))  # ✅ Positive
print(predict_sentiment_lstm("The visuals were cinematic, though the story dragged.", "Plot"))     # ✅ Negative
print(predict_sentiment_lstm("A thrilling suspenseful ride with twists and turns.", "Thriller"))   # ✅ Positive
print(predict_sentiment_lstm("The acting was phenomenal!", "Characters"))  # ❌ Invalid