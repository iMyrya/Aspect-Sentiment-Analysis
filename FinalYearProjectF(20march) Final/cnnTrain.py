# -*- coding: utf-8 -*-
"""cnn20A.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F4QZ6PeuxSyFEAnV2v4ozXl7Zzb3Zv34
"""

import pandas as pd
import numpy as np
import re
import tensorflow as tf
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Embedding, Conv1D, GlobalMaxPooling1D, Dense, Dropout, BatchNormalization
from tensorflow.keras.utils import to_categorical
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
import pickle

# Load dataset
df = pd.read_csv("movie_reviews_DLP.csv")

aspect_keywords = {
    "acting": [
        "acting", "actor", "actors", "performance", "performances", "cast", "role", "roles",
        "portrayal", "expressions", "dialogue", "screen presence", "chemistry",
        "delivery", "facial expressions", "body language", "acting skills"
    ],
    "plot": [
        "plot", "story", "storyline", "script", "twist", "twists", "narrative", "theme",
        "screenplay", "structure", "pace", "climax", "intro", "ending", "build-up", "backstory",
        "story arc", "writing", "subplots", "conflict", "chronology", "plotline"
    ],
    "sound": [
        "sound", "music", "score", "audio", "background score", "background music",
        "track", "melody", "tune", "composition", "soundtrack", "beats", "rhythm", "bass",
        "volume", "sound effects", "sound quality", "mixing", "sfx"
    ],
    "visuals": [
        "visuals", "cinematography", "cgi", "graphics", "animation", "camera", "effects",
        "focus", "lighting", "color", "color grading", "frame", "shot", "angles", "vfx",
        "aesthetics", "scenery", "set design", "visual appeal", "cinematic", "cinematic style"
    ],
    "direction": [
        "direction", "director", "directing", "vision", "filmmaking", "execution", "style",
        "tone", "narrative flow", "pacing", "creative choices", "scene setup", "visionary",
        "command", "directorial style", "cohesion", "presentation", "scene composition"
    ],
    "thriller": [
        "thriller", "thrilling", "thrills", "suspense", "tension", "mystery", "crime",
        "investigation", "detective", "clues", "twists", "twist", "shock", "surprise",
        "mind-bending", "edge of the seat", "on edge", "plot twist", "unexpected", "unexpected twists"
    ],
    "overall": []  # Accepts all
}

# Function to extract aspect-relevant clauses with better contrast handling
def extract_aspect_text(review, aspect):
    review = review.lower()
    splitters = r'[.!?;]| but | and | although | however | though | while '
    sentences = re.split(splitters, review)
    keywords = aspect_keywords.get(aspect.lower(), [])
    matched = []
    for sentence in sentences:
        if any(k in sentence for k in keywords):
            matched.append(sentence.strip())
    # Handle contrast - if sentence has contrast markers and aspect in one part, use that part only
    for sentence in re.split(r' but | although | however | though | while ', review):
        if any(k in sentence for k in keywords):
            return sentence.strip()
    return " ".join(matched) if matched else review

# Apply cleaning + filtering
df["Cleaned_Review"] = df.apply(lambda row: extract_aspect_text(str(row["Review"]), str(row["Aspect"])), axis=1)

# Tokenization
MAX_WORDS = 20000
MAX_LEN = 100

tokenizer = Tokenizer(num_words=MAX_WORDS, oov_token="<OOV>")
tokenizer.fit_on_texts(df["Cleaned_Review"].values)
sequences = tokenizer.texts_to_sequences(df["Cleaned_Review"].values)
X = pad_sequences(sequences, maxlen=MAX_LEN, padding='post', truncating='post')

# Encode aspects and sentiments
aspect_encoder = LabelEncoder()
aspects = aspect_encoder.fit_transform(df["Aspect"].values)
label_encoder = LabelEncoder()
labels = label_encoder.fit_transform(df["Sentiment"].values)
y = to_categorical(labels, num_classes=3)

# Split dataset
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, stratify=y, random_state=42)

# CNN Model
model = Sequential([
    Embedding(input_dim=MAX_WORDS, output_dim=128, input_length=MAX_LEN),
    Dropout(0.4),
    Conv1D(64, kernel_size=3, activation='relu', padding='same'),
    BatchNormalization(),
    Dropout(0.4),
    Conv1D(64, kernel_size=5, activation='relu', padding='same'),
    GlobalMaxPooling1D(),
    Dropout(0.4),
    Dense(64, activation='relu'),
    Dropout(0.5),
    Dense(3, activation='softmax')
])

model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

# Early stopping
early_stopping = tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=3, restore_best_weights=True)
model.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=20, batch_size=32, callbacks=[early_stopping], verbose=1)

# Save everything
model.save("Model/cnn_aspect_sentiment_model.h5")
with open("Model/cnn_tokenizer.pkl", "wb") as f:
    pickle.dump(tokenizer, f)
with open("Model/cnn_label_encoders.pkl", "wb") as f:
    pickle.dump((label_encoder, aspect_encoder), f)
print("✅ CNN model retrained and saved successfully!")

# Prediction function
def predict_sentiment_cnn(review, aspect):
    import pickle
    import numpy as np
    import re
    from tensorflow.keras.preprocessing.sequence import pad_sequences
    from tensorflow.keras.models import load_model

    MAX_LEN = 100

    # Load assets
    with open("Model/cnn_tokenizer.pkl", "rb") as f:
        tokenizer = pickle.load(f)
    with open("Model/cnn_label_encoders.pkl", "rb") as f:
        label_encoder, aspect_encoder = pickle.load(f)
    model = load_model("Model/cnn_aspect_sentiment_model.h5")

    aspect_lower = aspect.lower()
    available_aspects = [a.lower() for a in aspect_encoder.classes_]
    if aspect_lower not in available_aspects:
        return f"❌ Error: The aspect '{aspect}' is unavailable. Available aspects: {aspect_encoder.classes_}"

    # Segment & filter review
    splitters = r'[.!?;]| but | and | although | however | though | while '
    clauses = re.split(splitters, review.lower())
    keywords = aspect_keywords.get(aspect_lower, [])
    matched = []
    if aspect_lower != "overall":
        for clause in re.split(r' but | although | however | though | while ', review.lower()):
            if any(keyword in clause for keyword in keywords):
                matched.append(clause.strip())
        if not matched:
            return f"❌ Error: The review is not discussing the aspect '{aspect}'."
        review_to_use = " ".join(matched)
    else:
        review_to_use = review

    # Predict
    sequence = tokenizer.texts_to_sequences([review_to_use])
    padded_sequence = pad_sequences(sequence, maxlen=MAX_LEN, padding='post', truncating='post')
    prediction = model.predict(padded_sequence, verbose=0)
    sentiment = label_encoder.inverse_transform([np.argmax(prediction)])
    return f"✅ Sentiment for '{aspect}': {sentiment[0]}"

print(predict_sentiment_cnn("The acting was brilliant and captivating.", "Acting"))
# ✅ Sentiment for 'Acting': Positive

print(predict_sentiment_cnn("The visual effects were stunning and cinematic.", "Visuals"))
# ✅ Sentiment for 'Visuals': Positive

print(predict_sentiment_cnn("The music was dull and unmemorable.", "Sound"))
# ✅ Sentiment for 'Sound': Negative

print(predict_sentiment_cnn("The story was confusing and lacked clarity.", "Plot"))
# ✅ Sentiment for 'Plot': Negative

print(predict_sentiment_cnn("The music was amazing!", "Plot"))
# ❌ Error: The review is not discussing the aspect 'Plot'.

print(predict_sentiment_cnn("Overall, it was an enjoyable experience.", "Overall"))
# ✅ Sentiment for 'Overall': Positive


print("\n✅ REALISTIC & OUTSIDE-DATA REVIEWS (Correct Aspects)")
print(predict_sentiment_cnn("The acting was brilliant and captivating.", "Acting"))
# ✅ Sentiment for 'Acting': Positive

print(predict_sentiment_cnn("The visual effects were stunning and cinematic.", "Visuals"))
# ✅ Sentiment for 'Visuals': Positive

print(predict_sentiment_cnn("The music was dull and unmemorable.", "Sound"))
# ✅ Sentiment for 'Sound': Negative

print(predict_sentiment_cnn("The story was confusing and lacked clarity.", "Plot"))
# ✅ Sentiment for 'Plot': Negative

print(predict_sentiment_cnn("Direction felt tight and well-executed throughout the film.", "Direction"))
# ✅ Sentiment for 'Direction': Positive

print(predict_sentiment_cnn("It kept me on edge the whole time with unexpected twists.", "Thriller"))
# ✅ Sentiment for 'Thriller': Positive


print("\n❌ MISMATCHED ASPECT (Wrong keyword for selected aspect)")
print(predict_sentiment_cnn("The music was amazing!", "Plot"))
# ❌ Error: The review is not discussing the aspect 'Plot'.

print(predict_sentiment_cnn("The visual effects were next level.", "Sound"))
# ❌ Error: The review is not discussing the aspect 'Sound'.


print("\n❌ INVALID ASPECT NAME")
print(predict_sentiment_cnn("The acting was phenomenal and made the movie shine.", "Characters"))
# ❌ Error: The aspect 'Characters' is unavailable. Available aspects: ['Acting', 'Direction', 'Overall', 'Plot', 'Sound', 'Thriller', 'Visuals']


print("\n✅ GENERAL NEUTRAL REVIEWS (For 'Overall')")
print(predict_sentiment_cnn("Overall, it was an enjoyable experience.", "Overall"))
# ✅ Sentiment for 'Overall': Positive

print(predict_sentiment_cnn("Not great, not terrible. Just okay.", "Overall"))
# ✅ Sentiment for 'Overall': Neutral

print(predict_sentiment_cnn("It had a bit of everything but nothing stood out too much.", "Overall"))
# ✅ Sentiment for 'Overall': Neutral


print("\n✅ TRICKY MIXED REVIEWS (Should still predict correctly)")
print(predict_sentiment_cnn("The acting was good, but the plot was a mess.", "Acting"))
# ✅ Sentiment for 'Acting': Positive

print(predict_sentiment_cnn("Amazing cinematography, though the story dragged a bit.", "Visuals"))
# ✅ Sentiment for 'Visuals': Positive

print(predict_sentiment_cnn("The acting was good, but the plot was terrible.", "Acting"))
# ✅ Sentiment for 'Acting': Positive

print(predict_sentiment_cnn("The visuals were beautiful. However, the story was too slow.", "Visuals"))
# ✅ Sentiment for 'Visuals': Positive

print(predict_sentiment_cnn("It was suspenseful and had shocking twists!", "Thriller"))
# ✅ Sentiment for 'Thriller': Positive

print(predict_sentiment_cnn("The soundtrack and music were absolutely stunning.", "Sound"))
# ✅ Sentiment for 'Sound': Positive

print(predict_sentiment_cnn("Overall, the movie had good elements, but something was missing.", "Overall"))
# ✅ Sentiment for 'Overall': Neutral

print(predict_sentiment_cnn("The acting was amazing but the music was bad","Acting"))
# ✅ Sentiment for 'Acting': Positive

print(predict_sentiment_cnn("The acting was amazing but the music was bad","Sound"))
# ✅ Sentiment for 'Sound': Negative

print("\n✅ TRICKY MIXED REVIEWS (Should still predict correctly)")
print(predict_sentiment_cnn("The acting was good, but the plot was a mess.", "Plot"))
print(predict_sentiment_cnn("The acting was amazing, but the plot was a mess.", "Acting"))
print(predict_sentiment_cnn("The acting was good, but sound was dull.", "Sound"))
# ✅ Sentiment for 'Acting': Positive